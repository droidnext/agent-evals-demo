"""Data search utilities for cruise data - separates search from loading."""

import json
from pathlib import Path
from typing import Any, Dict, List, Optional

import numpy as np
import pandas as pd

try:
    import duckdb
except ImportError:  # pragma: no cover - handled gracefully at runtime
    duckdb = None

from ..utils.logger import get_logger
from ..utils.phoenix_tracer import tracer

logger = get_logger(__name__)


class DataSearch:
    """Searches cruise data using table-based queries.
    
    This class is separate from DataLoader to maintain clean separation:
    - DataLoader: Loads and injects data into systems
    - DataSearch: Searches and queries existing data
    """
    
    def __init__(self, data_dir: str = "data"):
        self.data_dir = Path(data_dir)
        self.cruises: List[Dict[str, Any]] = []
        self.pricing_df: Optional[pd.DataFrame] = None
        self._load_data()
    
    def _load_data(self):
        """Load data for searching."""
        # Load JSONL
        jsonl_path = self.data_dir / "cruises.jsonl"
        if jsonl_path.exists():
            try:
                with open(jsonl_path, 'r', encoding='utf-8') as f:
                    self.cruises = [json.loads(line.strip()) for line in f if line.strip()]
                logger.info(f"DataSearch loaded {len(self.cruises)} cruises")
            except Exception as e:
                logger.error(f"Error loading cruises: {e}")
        
        # Load Parquet
        parquet_path = self.data_dir / "cruises.parquet"
        if parquet_path.exists():
            try:
                self.pricing_df = pd.read_parquet(parquet_path)
                logger.info(f"DataSearch loaded {len(self.pricing_df)} pricing rows")
            except Exception as e:
                logger.error(f"Error loading pricing: {e}")
    
    def reload_data(self):
        """Reload data from files."""
        logger.info("Reloading data...")
        self._load_data()
    
    @tracer.chain
    def execute_sql_query(
        self,
        sql_query: str,
    ) -> List[Dict[str, Any]]:
        """Execute a raw SQL query against the cruise data using DuckDB.

        Exposes the underlying tabular data as DuckDB tables so that agents
        can construct arbitrary SQL queries (possibly generated by an LLM).

        Tables:
            - cruises: main cruise metadata, from the JSONL file
            - pricing: pricing information, from the Parquet file (if available)
        """
        if duckdb is None:
            raise RuntimeError("DuckDB is not installed; cannot execute SQL queries.")

        if not self.cruises:
            logger.warning("No cruise data loaded; SQL query will run against empty table.")

        # Build DataFrames
        cruises_df = pd.DataFrame(self.cruises) if self.cruises else pd.DataFrame()
        pricing_df = self.pricing_df if self.pricing_df is not None else pd.DataFrame()

        try:
            con = duckdb.connect()
            # Register cruises table - ensure it has at least one column for DuckDB
            if len(cruises_df.columns) > 0:
                con.register("cruises", cruises_df)
            else:
                # Create empty DataFrame with expected schema for cruises
                con.register("cruises", pd.DataFrame(columns=["cruise_id", "ship_name", "departure_port"]))
            
            # Register pricing table - ensure it has at least one column for DuckDB
            if len(pricing_df.columns) > 0:
                con.register("pricing", pricing_df)
            else:
                # Create empty DataFrame with expected schema for pricing
                con.register("pricing", pd.DataFrame(columns=["cruise_id", "starting_price"]))

            result_df = con.sql(sql_query).df()

            # Ensure all values are JSON-serializable (avoid NumPy arrays / dtypes)
            def _to_serializable(value: Any) -> Any:
                if isinstance(value, np.ndarray):
                    return value.tolist()
                if isinstance(value, np.generic):
                    # Convert NumPy scalar (e.g., int64, float64) to Python scalar
                    return value.item()
                return value

            result_df = result_df.applymap(_to_serializable)
            logger.info(f"Executed SQL query, returned {len(result_df)} rows")
            return result_df.to_dict(orient="records")
        except Exception as e:
            error_msg = str(e)
            # Enhance error message with schema information for column errors
            if "not found" in error_msg.lower() or "column" in error_msg.lower():
                schema = self.get_schema()
                schema_info = "\n".join([
                    f"  - {table}({', '.join(columns)})"
                    for table, columns in schema.items()
                ])
                error_msg = f"{error_msg}\n\nAvailable schema:\n{schema_info}"
            logger.error(f"Error executing SQL query: {error_msg}")
            raise RuntimeError(error_msg) from e
    
    def get_cruise_by_id(self, cruise_id: str) -> Optional[Dict[str, Any]]:
        """Get a specific cruise by ID."""
        for cruise in self.cruises:
            if cruise.get("cruise_id") == cruise_id or cruise.get("id") == cruise_id:
                return cruise
        return None
    
    def get_pricing(self, cruise_id: str) -> Optional[Dict[str, Any]]:
        """Get pricing information for a cruise."""
        if self.pricing_df is None or self.pricing_df.empty:
            return None
        
        # Search in pricing DataFrame
        matches = self.pricing_df[self.pricing_df.get("cruise_id", "") == cruise_id]
        if not matches.empty:
            return matches.iloc[0].to_dict()
        return None
    
    def search_by_price_range(
        self,
        min_price: Optional[float] = None,
        max_price: Optional[float] = None,
        limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Search cruises by price range."""
        if self.pricing_df is None or self.pricing_df.empty:
            return []
        
        # Filter pricing data
        filtered_df = self.pricing_df.copy()
        if min_price is not None:
            filtered_df = filtered_df[filtered_df["starting_price"] >= min_price]
        if max_price is not None:
            filtered_df = filtered_df[filtered_df["starting_price"] <= max_price]
        
        # Get cruise IDs
        cruise_ids = filtered_df["cruise_id"].tolist()[:limit]
        
        # Return matching cruises
        return [c for c in self.cruises if c.get("cruise_id") in cruise_ids or c.get("id") in cruise_ids]
    
    def get_all_cruises(self, limit: Optional[int] = None) -> List[Dict[str, Any]]:
        """Get all cruises."""
        if limit:
            return self.cruises[:limit]
        return self.cruises.copy()
    
    def get_schema(self) -> Dict[str, List[str]]:
        """Get schema information for all tables.
        
        Returns:
            Dictionary mapping table names to lists of column names.
        """
        schema = {}
        
        # Get cruises schema
        if self.cruises:
            cruises_df = pd.DataFrame(self.cruises)
            schema["cruises"] = cruises_df.columns.tolist()
        else:
            # Default schema if no data loaded
            schema["cruises"] = [
                "cruise_id", "ship_name", "departure_port", "departure_date",
                "duration", "destination", "ports_of_call", "cabin_type",
                "price_per_person", "total_price", "availability", "amenities", "description"
            ]
        
        # Get pricing schema
        if self.pricing_df is not None and not self.pricing_df.empty:
            schema["pricing"] = self.pricing_df.columns.tolist()
        else:
            # Default schema if no data loaded
            schema["pricing"] = ["cruise_id", "starting_price"]
        
        return schema
    
    def get_stats(self) -> Dict[str, Any]:
        """Get data statistics."""
        return {
            "total_cruises": len(self.cruises),
            "total_pricing_rows": len(self.pricing_df) if self.pricing_df is not None else 0,
            "has_pricing_data": self.pricing_df is not None and not self.pricing_df.empty,
        }
